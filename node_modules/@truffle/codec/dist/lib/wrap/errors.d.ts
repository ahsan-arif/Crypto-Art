import { Method, Resolution } from "./types";
import { WrapRequest, WrapResponse } from "../types";
import * as Format from "../format";
/**
 * This error indicates that no overloads matched when performing
 * overload resolution.  If there was only one plausible match,
 * a [[TypeMismatchError]] will be thrown instead.
 * @category Errors
 */
export declare class NoOverloadsMatchedError extends Error {
    methods: Method[];
    inputs: any[];
    userDefinedTypes: Format.Types.TypesById;
    constructor(methods: Method[], inputs: any[], userDefinedTypes: Format.Types.TypesById);
}
/**
 * This error indicates that multiple overloads matched during
 * overload resolution, but none of them was the unique best
 * overload.
 * @category Errors
 */
export declare class NoUniqueBestOverloadError extends Error {
    resolutions: Resolution[];
    constructor(resolutions: Resolution[]);
}
/**
 * This error indicates that the given input could not be recognized as the
 * type it was supposed to be.
 * @category Errors
 */
export declare class TypeMismatchError extends Error {
    variableName: string;
    reason: string;
    dataType: Format.Types.Type;
    input: any;
    constructor(dataType: Format.Types.Type, input: any, variableName: string, reason: string);
}
export declare class BadResponseTypeError extends Error {
    request: WrapRequest;
    response: WrapResponse;
    constructor(request: WrapRequest, response: WrapResponse);
}
