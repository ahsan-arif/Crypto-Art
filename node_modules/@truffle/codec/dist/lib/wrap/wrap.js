"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrap = void 0;
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("codec:wrap:wrap");
const Format = __importStar(require("../format"));
const errors_1 = require("./errors");
const elementary_1 = require("./elementary");
const Utils = __importStar(require("./utils"));
const EvmUtils = __importStar(require("../evm/utils"));
const lodash_isstring_1 = __importDefault(require("lodash.isstring")); //recognizes string *or* String
const Web3Utils = require("web3-utils"); //importing untyped, sorry!
function wrongArrayLengthMessage(expected, got) {
    return `Incorrect array length (expected ${expected.toString()} entries, got ${got})`;
}
const base64Pattern = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}([A-Za-z0-9+/]|=)=)?$/; //Vim's syntax highlighting is wrong here
function base64Length(base64) {
    const [_, endingEquals] = base64.match(/(=*)$/); //note this match always succeeds
    return (base64.length * 3) / 4 - endingEquals.length;
}
function* wrap(dataType, input, wrapOptions) {
    if (!wrapOptions.name) {
        wrapOptions = Object.assign(Object.assign({}, wrapOptions), { name: "<input>" });
    }
    debug("dataType.typeClass: %s", dataType.typeClass);
    switch (dataType.typeClass) {
        case "uint":
        case "int":
        case "enum":
            //these aren't quite the same, but the differences will be handled
            //in the common function
            return yield* elementary_1.wrapIntegerOrEnum(dataType, input, wrapOptions);
        case "fixed":
        case "ufixed":
            return yield* elementary_1.wrapDecimal(dataType, input, wrapOptions);
        case "bool":
            return elementary_1.wrapBool(dataType, input, wrapOptions);
        case "bytes":
            return elementary_1.wrapBytes(dataType, input, wrapOptions);
        case "address":
        case "contract":
            //we'll treat these the same
            return yield* elementary_1.wrapAddress(dataType, input, wrapOptions);
        case "string":
            return elementary_1.wrapString(dataType, input, wrapOptions);
        case "array":
            return yield* wrapArray(dataType, input, wrapOptions);
        case "tuple":
        case "struct":
            //we'll handle these similarly as well
            return yield* wrapTuple(dataType, input, wrapOptions);
        case "function":
            //we coerce here because we're not handling internal functions
            return yield* wrapFunctionExternal(dataType, input, wrapOptions);
        case "options":
            return yield* wrapTxOptions(dataType, input, wrapOptions);
    }
}
exports.wrap = wrap;
function* wrapArray(dataType, input, wrapOptions) {
    let value = [];
    if (Array.isArray(input)) {
        if (dataType.kind === "dynamic" || dataType.length.eqn(input.length)) {
            //can't do yield in a map, so manual loop here
            for (let index = 0; index < input.length; index++) {
                value.push(yield* wrap(dataType.baseType, input[index], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}[${index}]` })));
            }
        }
        else {
            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, wrongArrayLengthMessage(dataType.length, input.length));
        }
    }
    else if (Utils.isWrappedResult(input)) {
        //1. is it already wrapped, and matches the requested type?
        //(we won't bother with detailed typechecking as much of it is handled
        //elsewhere; we will check dynamic vs static though as that isn't)
        switch (input.kind) {
            case "value":
                if (input.type.typeClass === "array") {
                    if (!wrapOptions.loose && input.type.kind === dataType.kind) {
                        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.wrappedTypeMessage(input.type));
                    }
                    else {
                        return yield* wrapArray(dataType, input.value, wrapOptions);
                    }
                }
                else {
                    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.wrappedTypeMessage(input.type));
                }
            case "error":
                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.errorResultMessage);
        }
    }
    else if (Utils.isTypeValueInput(input)) {
        //2. is it a type/value?
        //if so wrap input.value
        //don't turn on loose here, only do that for non-container types!
        if (input.type === "array") {
            return yield* wrapArray(dataType, input.value, wrapOptions);
        }
        else {
            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.specifiedTypeMessage(input.type));
        }
    }
    else {
        //we don't know what it is
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, "Input was not an array, type/value pair or wrapped array");
    }
    return {
        type: dataType,
        kind: "value",
        value
    };
}
//even with loose turned off, we won't distinguish
//between tuples and structs
function* wrapTuple(dataType, input, wrapOptions) {
    let memberTypes;
    switch (dataType.typeClass) {
        case "tuple":
            memberTypes = dataType.memberTypes;
            break;
        case "struct":
            debug("wrapping for struct %s", dataType.typeName);
            memberTypes = (Format.Types.fullType(dataType, wrapOptions.userDefinedTypes)).memberTypes;
            break;
    }
    debug("memberTypes: %O", memberTypes);
    let value = [];
    if (Array.isArray(input)) {
        debug("input is array");
        if (memberTypes.length === input.length) {
            //can't do yield in a map, so manual loop here
            for (let index = 0; index < input.length; index++) {
                const memberName = memberTypes[index].name;
                debug("wrapping %s", memberName);
                value.push({
                    name: memberName,
                    value: yield* wrap(memberTypes[index].type, input[index], Object.assign(Object.assign({}, wrapOptions), { name: memberName
                            ? wrapOptions.name.match(/^<.*>$/) //hack?
                                ? memberName
                                : `${wrapOptions.name}.${memberName}`
                            : `${wrapOptions.name}[${index}]` }))
                });
            }
        }
        else {
            debug("input is wrong-length array");
            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, wrongArrayLengthMessage(memberTypes.length, input.length));
        }
    }
    else if (Utils.isWrappedResult(input)) {
        //1. is it already wrapped, and matches the requested type?
        //not going to do much typechecking here as it'll be handled on recursion
        switch (input.kind) {
            case "value":
                switch (input.type.typeClass) {
                    case "tuple":
                    case "struct":
                        let coercedInput = input; //HACK!
                        //Typescript complains if I try to say it can be either struct or
                        //tuple, so, uh, let's just tell it it's a tuple <shrug>
                        return yield* wrapTuple(dataType, coercedInput.value.map(({ value }) => value), wrapOptions);
                    default:
                        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.wrappedTypeMessage(input.type));
                }
            case "error":
                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.errorResultMessage);
        }
    }
    else if (Utils.isTypeValueInput(input)) {
        //2. is it a type/value?
        //if so wrap input.value
        //don't turn on loose here, only do that for non-container types!
        if (input.type === "struct" || input.type === "tuple") {
            return yield* wrapTuple(dataType, input.value, wrapOptions);
        }
        else {
            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.specifiedTypeMessage(input.type));
        }
    }
    else if (Utils.isPlainObject(input)) { //just checks that it's an object & not null
        if (memberTypes.some(({ name }) => !name)) {
            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, "Plain object input is not allowed when not all elements of tuple are named");
        }
        let unusedKeys = new Set(Object.keys(input));
        for (let index = 0; index < memberTypes.length; index++) {
            //note we had better process these in order!
            const memberName = memberTypes[index].name;
            if (!(memberName in input)) {
                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, `Missing key from tuple or struct: ${memberName}`);
            }
            unusedKeys.delete(memberName);
            value.push({
                name: memberName,
                value: yield* wrap(memberTypes[index].type, input[memberName], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${memberName}` }))
            });
        }
        if (!wrapOptions.loose) {
            if (unusedKeys.size > 0) {
                //choose one arbitrarily
                const exampleKey = unusedKeys.values().next().value;
                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, `Unknown key ${exampleKey} included`);
            }
        }
    }
    else {
        //we don't know what it is
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, "Input was not an array, plain object, type/value pair or wrapped tuple or struct");
    }
    //we need to coerce here because TS doesn't know that if it's a struct
    //then everything has a name
    return {
        type: dataType,
        kind: "value",
        value
    };
}
function* wrapFunctionExternal(dataType, input, wrapOptions) {
    let address, selector;
    if (Utils.isWrappedResult(input)) {
        //1. is it already wrapped?
        switch (input.kind) {
            case "value":
                if (input.type.typeClass !== "function" ||
                    input.type.visibility !== "external") {
                    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.wrappedTypeMessage(input.type));
                }
                const coercedInput = input;
                address = coercedInput.value.contract.address;
                selector = coercedInput.value.selector;
                break;
            case "error":
                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.errorResultMessage);
        }
    }
    else if (Utils.isTypeValueInput(input)) {
        //2. is it a type/value?
        //if so wrap input.value (with loose on so strings will work)
        if (input.type !== "function") {
            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.specifiedTypeMessage(input.type));
        }
        //because function, unlike other "containers", has specific types, we will turn on loose
        return yield* wrapFunctionExternal(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }));
    }
    else if (Utils.isFunctionExternalInput(input)) {
        //we'll treat address and selector like sub-variables
        const wrappedAddress = (yield* elementary_1.wrapAddress({ typeClass: "address", kind: "general" }, input.address, Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.address` })));
        address = wrappedAddress.value.asAddress;
        const wrappedSelector = elementary_1.wrapBytes({ typeClass: "bytes", kind: "static", length: 4 }, input.selector, Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.selector` }));
        selector = wrappedSelector.value.asHex;
    }
    else if (typeof input === "string") {
        //we'll allow a raw bytestring in this case
        //note in this case, unlike the other cases, we mostly handle validation up front
        if (!input.match(elementary_1.byteStringPattern)) {
            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, "Input was a string, but not a valid even-length hex string");
        }
        if (input.length !==
            2 + 2 * (EvmUtils.ADDRESS_SIZE + EvmUtils.SELECTOR_SIZE)) {
            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.wrongLengthMessage("external function was given as a string but", EvmUtils.ADDRESS_SIZE + EvmUtils.SELECTOR_SIZE, (input.length - 2) / 2));
        }
        address = input.slice(0, EvmUtils.ADDRESS_SIZE * 2 + 2).toLowerCase(); //bypass checksum validation here
        selector = "0x" + input.slice(EvmUtils.ADDRESS_SIZE * 2 + 2).toLowerCase();
    }
    else if (lodash_isstring_1.default(input)) {
        return yield* wrapFunctionExternal(dataType, input.valueOf(), wrapOptions);
    }
    else {
        //we don't know what it is
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, "Input should be one of: an object with address and selector; a 24-byte hex string; a type/value pair; or a wrapped external function");
    }
    //now: validate the address
    if (!address.match(elementary_1.byteStringPattern)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.notABytestringMessage("Address"));
    }
    if (address.length !== 2 * EvmUtils.ADDRESS_SIZE + 2) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.wrongLengthMessage("address", EvmUtils.ADDRESS_SIZE, (address.length - 2) / 2));
    }
    if (!Web3Utils.isAddress(address)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.checksumFailedMessage);
    }
    //normalize the address
    address = Web3Utils.toChecksumAddress(address);
    //validate the selector
    if (!selector.match(elementary_1.byteStringPattern)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.notABytestringMessage("Selector"));
    }
    if (selector.length !== 2 * EvmUtils.SELECTOR_SIZE + 2) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.wrongLengthMessage("selector", EvmUtils.SELECTOR_SIZE, (selector.length - 2) / 2));
    }
    return {
        type: dataType,
        kind: "value",
        value: {
            kind: "unknown",
            contract: {
                kind: "unknown",
                address
            },
            selector
        }
    };
}
//not called wrapOptions to avoid name collision there!
function* wrapTxOptions(dataType, input, wrapOptions) {
    let value = {};
    if (Utils.isWrappedResult(input)) {
        //1. is it already wrapped?
        switch (input.kind) {
            case "value":
                if (input.type.typeClass === "options") {
                    value = input.value;
                }
                else {
                    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.wrappedTypeMessage(input.type));
                }
                break;
            case "error":
                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.errorResultMessage);
        }
    }
    else if (Utils.isTypeValueInput(input)) {
        //2. is it a type/value?
        //because options, unlike other containers, has specific types, we will turn on loose
        if (input.type === "options") {
            return yield* wrapTxOptions(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }));
        }
        else {
            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, elementary_1.specifiedTypeMessage(input.type));
        }
    }
    else if (Utils.isPlainObject(input)) { //just checks if it's an object & not null
        const uintKeys = ["gas", "gasPrice", "value", "nonce"];
        const addressKeys = ["from", "to"];
        const bytesKeys = ["data"];
        const boolKeys = ["overwrite"];
        const specialKeys = ["privateFor"];
        const allKeys = [
            ...uintKeys,
            ...addressKeys,
            ...bytesKeys,
            ...boolKeys,
            ...specialKeys
        ];
        const badKey = Object.keys(input).find(key => !allKeys.includes(key));
        const goodKey = Object.keys(input).find(key => allKeys.includes(key));
        if (badKey !== undefined && !wrapOptions.oldOptionsBehavior) {
            //note we allow extra keys if oldOptionsBehavior is on -- this is a HACK
            //to preserve existing behavior of Truffle Contract (perhaps we can
            //change this in Truffle 6)
            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, `Transaction options included unknown option ${badKey}`);
        }
        if (wrapOptions.oldOptionsBehavior && goodKey === undefined) {
            //similarly, if oldOptionsBehavior is on, we require at least
            //one *legit* key (again, HACK to preserve existing behavior,
            //maybe remove this in Truffle 6)
            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, `Transaction options included no recognized options`);
        }
        //otherwise, if all keys are transaction options, let's process them...
        //part 1: uint options
        for (const key of uintKeys) {
            //note we check input[key] !== undefined, rather than key in input,
            //because if one of them is undefined we want to just allow that but ignore it
            if (input[key] !== undefined) {
                const wrappedOption = (yield* elementary_1.wrapIntegerOrEnum({ typeClass: "uint", bits: 256 }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` })));
                value[key] = wrappedOption.value.asBN;
            }
        }
        //part 2: address options
        for (const key of addressKeys) {
            if (input[key] !== undefined) {
                const wrappedOption = (yield* elementary_1.wrapAddress({ typeClass: "address", kind: "general" }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` })));
                value[key] = wrappedOption.value.asAddress;
            }
        }
        //part 3: bytestring options
        for (const key of bytesKeys) {
            if (input[key] !== undefined) {
                const wrappedOption = elementary_1.wrapBytes({ typeClass: "bytes", kind: "dynamic" }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }));
                value[key] = wrappedOption.value.asHex;
            }
        }
        //part 3: boolean options
        for (const key of boolKeys) {
            if (input[key] !== undefined) {
                const wrappedOption = elementary_1.wrapBool({ typeClass: "bool" }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }));
                value[key] = wrappedOption.value.asBoolean;
            }
        }
        //part 4: special cases
        if (input.privateFor !== undefined) {
            //this doesn't correspond to any of our usual types, so we have to handle it specially
            if (!Array.isArray(input.privateFor)) {
                throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, "Transaction option privateFor should be an array of base64-encoded bytestrings of 32 bytes");
            }
            value.privateFor = input.privateFor.map((publicKey, index) => {
                if (typeof publicKey !== "string" && lodash_isstring_1.default(publicKey)) {
                    publicKey = publicKey.valueOf();
                }
                if (typeof publicKey !== "string") {
                    throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, `Public key at index ${index} is not a string`);
                }
                if (!publicKey.match(base64Pattern)) {
                    throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, `Public key at index ${index} is not base64-encoded`);
                }
                const length = base64Length(publicKey);
                if (length !== 32) {
                    throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, `Public key at index ${index} should encode a bytestring of 32 bytes; got ${length} bytes instead`);
                }
                return publicKey;
            });
        }
    }
    else {
        //we don't know what it is
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, "Transaction options input was not a plain object, type/value pair or wrapped options object");
    }
    return {
        type: dataType,
        kind: "value",
        value
    };
}
//# sourceMappingURL=wrap.js.map