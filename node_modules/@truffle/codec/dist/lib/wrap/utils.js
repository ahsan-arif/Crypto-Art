"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPlainObject = exports.isUint8ArrayLikeInput = exports.isWrappedResult = exports.isFunctionExternalInput = exports.isContractInput = exports.isEncodingTextInput = exports.isTypeValueInput = exports.isSafeNumber = exports.minValue = exports.maxValue = exports.places = void 0;
const big_js_1 = __importDefault(require("big.js"));
const Conversion = __importStar(require("../conversion"));
function places(dataType) {
    switch (dataType.typeClass) {
        case "int":
        case "uint":
            return 0;
        case "fixed":
        case "ufixed":
            return dataType.places;
    }
}
exports.places = places;
function maxValue(dataType) {
    let bits = dataType.bits;
    if (dataType.typeClass === "int" || dataType.typeClass === "fixed") {
        bits -= 1; //subtract 1 for signed
    }
    const maxIntegerValue = new big_js_1.default(2).pow(bits).minus(1);
    return Conversion.shiftBigDown(maxIntegerValue, places(dataType));
}
exports.maxValue = maxValue;
function minValue(dataType) {
    if (dataType.typeClass === "uint" || dataType.typeClass === "ufixed") {
        return new big_js_1.default(0);
    }
    const minIntegerValue = new big_js_1.default(0).minus(new big_js_1.default(2).pow(dataType.bits));
    return Conversion.shiftBigDown(minIntegerValue, places(dataType));
}
exports.minValue = minValue;
function isSafeNumber(dataType, input) {
    const scaledUp = input * (10 ** dataType.places);
    return Number.MIN_SAFE_INTEGER <= scaledUp &&
        scaledUp <= Number.MAX_SAFE_INTEGER;
}
exports.isSafeNumber = isSafeNumber;
function isTypeValueInput(input) {
    return (typeof input === "object" &&
        input !== null &&
        typeof input.type === "string" &&
        "value" in input &&
        Object.keys(input).length === 2);
}
exports.isTypeValueInput = isTypeValueInput;
function isEncodingTextInput(input) {
    return (typeof input === "object" &&
        input !== null &&
        typeof input.encoding === "string" &&
        typeof input.text === "string" &&
        Object.keys(input).length === 2);
}
exports.isEncodingTextInput = isEncodingTextInput;
function isContractInput(input) {
    return (typeof input === "object" &&
        input !== null &&
        typeof input.address === "string" &&
        //we *don't* check anything more for addresses, we'll let the
        //address wrapper handle that
        !("selector" in input));
}
exports.isContractInput = isContractInput;
function isFunctionExternalInput(input) {
    return (typeof input === "object" &&
        input !== null &&
        "address" in input &&
        "selector" in input);
}
exports.isFunctionExternalInput = isFunctionExternalInput;
function isWrappedResult(input) {
    return (typeof input === "object" &&
        input !== null &&
        typeof input.type === "object" &&
        input.type !== null &&
        typeof input.type.typeClass === "string" &&
        ((input.kind === "value" && typeof input.value === "object") ||
            (input.kind === "error" && typeof input.error === "object")));
}
exports.isWrappedResult = isWrappedResult;
function isUint8ArrayLikeInput(input) {
    return (typeof input === "object" &&
        input !== null &&
        typeof input.length === "number");
}
exports.isUint8ArrayLikeInput = isUint8ArrayLikeInput;
//hack?
function isPlainObject(input) {
    return typeof input === "object" && input !== null;
}
exports.isPlainObject = isPlainObject;
//# sourceMappingURL=utils.js.map